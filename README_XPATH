= XML-XPATH

== Overview, Motivation

Xml-xpath is an (incomplete) XPath interpreter that is at the moment
bundled with xml-mapping. It is built on top of REXML. xml-mapping
uses xml-xpath extensively for implementing its node types -- see the
README file and the reference documentation (and the source code) for
details. xml-xpath, however, does not depend on xml-mapping at all,
and is useful in its own right -- maybe I'll later distribute it as a
seperate library instead of bundling it. xml-xpath's XPath support is
vastly incomplete (see below), but, in addition to the normal
reading/matching functionality found in other XPath implementations
(i.e. "find all elements in a given XML document matching a given
XPath expression"), xml-xpath supports <i>write access</i>. For
example, when writing the XPath expression
"/foo/bar[3]/baz[@key='hiho']" to the XML document

  <foo>
    <bar>
      <baz key='ab'>hello</baz>
      <baz key='xy'>goodbye</baz>
    </bar>
  </foo>

, you'll get:

  <foo>
    <bar>
      <baz key='ab'>hello</baz>
      <baz key='xy'>goodbye</baz>
    </bar>
    <bar/>
    <bar><baz key='hiho'/></bar>
  </foo>

This feature is used by xml-mapping when writing (marshalling) Ruby
objects to XML, and is actually the reason why I couldn't just use any
of the existing XPath implementations, e.g. the one that comes with
REXML. Also, the whole xml-xpath implementation is just 300 lines of
Ruby code, it is quite fast (paths are precompiled), and xml-xpath
returns matched elements in the order they appeared in the source
document -- I've heard REXML::XPath doesn't do that :)

Some basic knowledge of XPath is helpful for reading this document (I
don't know very much either).

At the moment, xml-xpath understands XPath expressions of the form
[<tt>/</tt>]_pathelement_<tt>/</tt>_pathelement_<tt>/</tt>..., where
each _pathelement_ must be one of these:

- a simple element name _name_, e.g. +signature+

- an attribute name, @_attr_name_, e.g. <tt>@key</tt>

- a combination of an element name and an attribute name and
  -value, in the form _elt_name_[@_attr_name_='_attr_value_']

- an element name and an index, _elt_name_[_index_]

- the "match-all" path element, <tt>*</tt>


== Usage

Xml-xpath defines the class XML::XPath. An instance of that class
wraps an XPath expression, the string representation of which must be
supplied when constructing the instance. You then call instance
methods like _first_, _all_ or <i>create_new</i> on the instance,
supplying the REXML Element the XPath expression should be applied to,
and get the results, or, in the case of write access, the element is
updated in-place.


=== Read Access

  :include: xpath_usage.intout

The objects supplied to the <tt>all()</tt>, <tt>first()</tt>, and
<tt>each()</tt> calls must be REXML element nodes, i.e. they must
support messages like <tt>elements</tt>, <tt>attributes</tt> etc
(instances of REXML::Element and its subclasses do this). The calls
return the found elements as instances of REXML::Element or
XML::XPath::Accessors::Attribute. The latter is a wrapper around
attribute nodes that is largely call-compatible to
REXML::Element. This is so you can write things like
<tt>path.each{|node|puts node.text}</tt> without having to
special-case anything even if the path matches attributes, not just
elements.

The path elements of the XPath pattern are applied to the
<tt>.elements</tt> collection of the passed XML element and its
sub-elements, starting with the first one. This is shown by the
following code:

  :include: xpath_docvsroot.intout

A REXML +Document+ object is a REXML +Element+ object whose +elements+
collection consists only of a single member -- the document's root
node. The first path element of the XPath -- "foo" in the example --
is matched against that. That is why the path "/bar" in the example
doesn't match anything when matched against the document +d+ itself.

An ordinary REXML +Element+ object that represents a node somewhere
inside an XML tree has an +elements+ collection that consists of all
the element's direct sub-elements. That is why XPath patterns matched
against the +firstelt+ element in the example *must not* start with
"/first" (unless there is a child node that is also named "first").


=== Write Access



== Implentation notes
